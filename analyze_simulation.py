#!/usr/bin/env python3
"""
Simulation Analysis Tool

This script analyzes the CSV files generated by the complex simulation
and provides insights about mission performance, communication patterns,
and object detection efficiency.
"""

import csv
import math
from collections import defaultdict, Counter
from typing import Dict, List, Tuple

def load_csv_data(filename: str) -> List[Dict]:
    """Load CSV data into a list of dictionaries"""
    try:
        with open(filename, 'r') as file:
            reader = csv.DictReader(file)
            return list(reader)
    except FileNotFoundError:
        print(f"Warning: {filename} not found")
        return []

def analyze_mission_performance(log_data: List[Dict]) -> Dict:
    """Analyze overall mission performance"""
    if not log_data:
        return {}
    
    # Get mission updates
    mission_updates = [row for row in log_data if row['event_type'] == 'mission_update']
    
    if not mission_updates:
        return {}
    
    final_update = mission_updates[-1]
    
    # Calculate detection efficiency
    total_objects = int(final_update.get('objects_detected_total', 0))
    distance_traveled = float(final_update.get('distance_traveled', 0))
    
    efficiency = total_objects / distance_traveled if distance_traveled > 0 else 0
    
    return {
        'total_objects_detected': total_objects,
        'total_distance_traveled': distance_traveled,
        'detection_efficiency': efficiency,
        'mission_duration': len(mission_updates) * 10  # Updates every 10 ticks
    }

def analyze_communication_patterns(comm_data: List[Dict]) -> Dict:
    """Analyze communication success patterns"""
    if not comm_data:
        return {}
    
    # Group by distance ranges
    distance_ranges = {
        '0-100m': [],
        '100-200m': [],
        '200-300m': [],
        '300-500m': [],
        '500m+': []
    }
    
    for row in comm_data:
        try:
            distance = float(row.get('distance', 0))
            packet_lost = row.get('packet_lost', 'False').lower() == 'true'
            
            if distance <= 100:
                distance_ranges['0-100m'].append(not packet_lost)
            elif distance <= 200:
                distance_ranges['100-200m'].append(not packet_lost)
            elif distance <= 300:
                distance_ranges['200-300m'].append(not packet_lost)
            elif distance <= 500:
                distance_ranges['300-500m'].append(not packet_lost)
            else:
                distance_ranges['500m+'].append(not packet_lost)
        except (ValueError, TypeError):
            continue
    
    # Calculate success rates
    success_rates = {}
    for range_name, successes in distance_ranges.items():
        if successes:
            success_rates[range_name] = sum(successes) / len(successes)
        else:
            success_rates[range_name] = 0.0
    
    return success_rates

def analyze_object_distribution(objects_data: List[Dict]) -> Dict:
    """Analyze object types and detection patterns"""
    if not objects_data:
        return {}
    
    object_types = Counter()
    detected_types = Counter()
    distances_from_ship = []
    
    for row in objects_data:
        obj_type = row.get('object_type', 'unknown')
        detected = row.get('detected', 'False').lower() == 'true'
        
        object_types[obj_type] += 1
        if detected:
            detected_types[obj_type] += 1
        
        try:
            distance = float(row.get('distance_from_ship', 0))
            distances_from_ship.append(distance)
        except (ValueError, TypeError):
            pass
    
    # Calculate detection rates by type
    detection_rates = {}
    for obj_type, total in object_types.items():
        detected = detected_types.get(obj_type, 0)
        detection_rates[obj_type] = detected / total if total > 0 else 0
    
    # Calculate distance statistics
    if distances_from_ship:
        avg_distance = sum(distances_from_ship) / len(distances_from_ship)
        min_distance = min(distances_from_ship)
        max_distance = max(distances_from_ship)
    else:
        avg_distance = min_distance = max_distance = 0
    
    return {
        'object_counts': dict(object_types),
        'detection_rates': detection_rates,
        'distance_stats': {
            'average': avg_distance,
            'minimum': min_distance,
            'maximum': max_distance
        }
    }

def analyze_detection_timeline(detections_data: List[Dict]) -> Dict:
    """Analyze when and where objects were detected"""
    if not detections_data:
        return {}
    
    detections_by_tick = defaultdict(list)
    detection_distances = []
    
    for row in detections_data:
        try:
            tick = int(row.get('tick', 0))
            distance = float(row.get('detection_distance', 0))
            obj_type = row.get('object_type', 'unknown')
            
            detections_by_tick[tick].append({
                'type': obj_type,
                'distance': distance
            })
            detection_distances.append(distance)
        except (ValueError, TypeError):
            continue
    
    # Calculate detection timing
    if detections_by_tick:
        first_detection = min(detections_by_tick.keys())
        last_detection = max(detections_by_tick.keys())
        detection_span = last_detection - first_detection
    else:
        first_detection = last_detection = detection_span = 0
    
    # Calculate average detection distance
    avg_detection_distance = sum(detection_distances) / len(detection_distances) if detection_distances else 0
    
    return {
        'total_detections': len(detections_data),
        'first_detection_tick': first_detection,
        'last_detection_tick': last_detection,
        'detection_span': detection_span,
        'average_detection_distance': avg_detection_distance,
        'detections_per_tick': len(detections_data) / detection_span if detection_span > 0 else 0
    }

def print_analysis_report():
    """Generate and print a comprehensive analysis report"""
    print("=" * 80)
    print("📊 SIMULATION ANALYSIS REPORT")
    print("=" * 80)
    
    # Load data
    log_data = load_csv_data('complex_uuv_simulation_log.csv')
    comm_data = load_csv_data('complex_uuv_simulation_communication.csv')
    objects_data = load_csv_data('complex_uuv_simulation_objects.csv')
    detections_data = load_csv_data('complex_uuv_simulation_detections.csv')
    
    # Mission Performance
    mission_perf = analyze_mission_performance(log_data)
    if mission_perf:
        print(f"\n🎯 MISSION PERFORMANCE")
        print(f"   Objects detected: {mission_perf['total_objects_detected']}")
        print(f"   Distance traveled: {mission_perf['total_distance_traveled']:.1f}m")
        print(f"   Detection efficiency: {mission_perf['detection_efficiency']:.4f} objects/meter")
        print(f"   Mission duration: {mission_perf['mission_duration']} ticks")
    
    # Communication Analysis
    comm_patterns = analyze_communication_patterns(comm_data)
    if comm_patterns:
        print(f"\n📡 COMMUNICATION PATTERNS")
        for distance_range, success_rate in comm_patterns.items():
            print(f"   {distance_range}: {success_rate:.1%} success rate")
    
    # Object Analysis
    obj_analysis = analyze_object_distribution(objects_data)
    if obj_analysis:
        print(f"\n🔍 OBJECT ANALYSIS")
        print(f"   Object counts: {obj_analysis['object_counts']}")
        print(f"   Detection rates by type:")
        for obj_type, rate in obj_analysis['detection_rates'].items():
            print(f"     {obj_type}: {rate:.1%}")
        
        dist_stats = obj_analysis['distance_stats']
        print(f"   Distance from ship:")
        print(f"     Average: {dist_stats['average']:.1f}m")
        print(f"     Range: {dist_stats['minimum']:.1f}m - {dist_stats['maximum']:.1f}m")
    
    # Detection Timeline
    detection_timeline = analyze_detection_timeline(detections_data)
    if detection_timeline:
        print(f"\n⏱️  DETECTION TIMELINE")
        print(f"   Total detections: {detection_timeline['total_detections']}")
        print(f"   First detection: tick {detection_timeline['first_detection_tick']}")
        print(f"   Last detection: tick {detection_timeline['last_detection_tick']}")
        print(f"   Detection span: {detection_timeline['detection_span']} ticks")
        print(f"   Average detection distance: {detection_timeline['average_detection_distance']:.1f}m")
        print(f"   Detection rate: {detection_timeline['detections_per_tick']:.3f} detections/tick")
    
    print("\n" + "=" * 80)

def analyze_search_efficiency():
    """Analyze search pattern efficiency"""
    log_data = load_csv_data('complex_uuv_simulation_log.csv')
    
    if not log_data:
        return
    
    # Track submarine movement and detections
    positions = []
    detections = []
    
    for row in log_data:
        if row['event_type'] == 'status':
            try:
                x = float(row.get('pos_x', 0))
                y = float(row.get('pos_y', 0))
                z = float(row.get('pos_z', 0))
                tick = int(row.get('tick', 0))
                positions.append((tick, x, y, z))
            except (ValueError, TypeError):
                continue
        elif row['event_type'] == 'detection':
            try:
                tick = int(row.get('tick', 0))
                detections.append(tick)
            except (ValueError, TypeError):
                continue
    
    if positions and detections:
        print(f"\n🗺️  SEARCH PATTERN ANALYSIS")
        print(f"   Position samples: {len(positions)}")
        print(f"   Detection events: {len(detections)}")
        
        # Calculate search area coverage
        if len(positions) > 1:
            x_coords = [pos[1] for pos in positions]
            y_coords = [pos[2] for pos in positions]
            
            x_range = max(x_coords) - min(x_coords)
            y_range = max(y_coords) - min(y_coords)
            search_area = x_range * y_range
            
            print(f"   Search area: {search_area:.0f} m²")
            print(f"   X range: {x_range:.1f}m, Y range: {y_range:.1f}m")

if __name__ == "__main__":
    print_analysis_report()
    analyze_search_efficiency() 